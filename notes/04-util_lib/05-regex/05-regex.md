# RegExp

## introduction

#### regex introduction

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * regex
 * 
 * 
 * 正则表达式是一个规则，跨域语言，用于验证字符串
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### regex rule

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * /^([range]{quantifier})*]$/modifiers
 * 
 * 
 * @range:
 * @quantifier: 
 * @modifiers: global / ignoreCase / multiline
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## basic

#### special character

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 特殊字符

.                   // 匹配 任意单个字符( 除了换行和结束符 )

^[character]        // 匹配 以 [character] 开头的字符串

[character]$        // 匹配 以 [character] 结尾的字符串


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### escapes

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 转译符
 * 
 * 
 * 匹配规则 "仅可匹配单个字符"
 */


\n                      // Newline              匹配 换行符

\r                      // return               匹配 回车符( 不建议使用，通常仅 window 中有效 )

\t                      // table                匹配 制表符   

\v                      // vertical table       匹配 垂直制表符   

\f                      // find page            匹配 换页符

\s = [\f\n\r\t\v]       // space                匹配 空白字符

\S = !\s                // !space               匹配 非空白字符


\b                      // bound                匹配 单词边界

\B = !\b                // !bound               匹配 非单词边界


\d                      // digital              匹配 数字

\D = !\d                // !digital             匹配 非数字


\w = [A-Za-z0-9_]       // word                 匹配 字母，数字，下划线
\W = ![A-Za-z0-9_]      // !word                匹配 非字母，数字，下划线


\u                      // unicode              匹配 unicode 字符


\[character]            // 转译字符              匹配转译后的普通字符


...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// Unicode 编码


\u010000 - \u01ffff             // 十六进制

\u020000 - \u02ffff

\u100000 - \u10ffff


[\u0000-\uffff]/g               // all

[\s\S]                          // all

... ...


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### separator

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * [range]              // 单个字符的匹配范围约束
 * 
 * 
 * 匹配 单个字符 的 范围规则
 */
 
 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * {frequency}          // 修饰 [range] 的量词( 表示匹配的单个字符的出现次数 )
 * 
 * 
 * 修饰 [range] 出现的次数
 * 
 ** 修饰符 仅修饰 前一个相邻的 [range]
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * [^]          // 非
 * 
 * 表达式 中的 ^ 代表 非
 */
 
 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * |            // 或
 * 
 * 代表 或
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### frequency

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * frequency
 * 
 * 
 ** 量词仅作用于前一个兄弟元素 [range]
 */

[range_01][range_02]{frequency}             // 当前 {frequency} 仅作用于 [range_02]


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


@frequency: 频率/次数


*               // frequency >= 0                       匹配 任意次数

+               // frequency >= 1                       匹配 至少出现一次

?               // frequency = 0 | frequency = 1        匹配 出现0次 或 出现1次


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{count}         // frequency = count                    出现固定 count 次

{min,}          // frequency >= min                     最少出现 min 次

{min,max}       // min <= frequency <= max              最少出现 min 次，最多出现 max 次


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## create regexp

#### create regex methods

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * RegExp
 * 
 * 
 * 正则表达式表现为一个对象，该对象通过构造函数 RegExp 创建
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 1) 字面量创建
 * 
 * 
 * /regexp/[modifier]
 * 
 * 规则固定则建议使用该方法
 */

const reg1 = /reg/;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 2) 构造函数创建
 * 
 * 
 * new RegExp((pattern: string , RegExp), modifiers: string): regexp;
 * 
 * 规则不固定则建议使用该方法
 */


// 通过 new 创建

const reg2 = new RegExp(reg1);          // 返回 新的 reg
=> reg1 !== reg2;


// 直接调用构造函数创建

const reg3 = RegExp(reg1);              // 返回 reg1
=> reg3 === reg1


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### modifiers

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 修饰符
 * 
 * 
 * /reg/[modifier]
 */


var reg = /reg/i;               // ignoreCase           // 忽略大小写

var reg = /reg/g;               // global               // 执行全局匹配，返回所有相匹配的结果

var reg = /reg/m;               // multiline            // 执行多行匹配, \n 换行后的字符


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


var str = "adbca";

str.match(/a/g);                // ['a', 'a']

str.match(/^a/g);               // ['a']


var str1 = 'adbc/na';

str.match(/^a/g);               // ['a']

str.match(/^a/gm);              // ['a', 'a']              // 此时才是多行匹配


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## advance

#### RegExp.prototype.method

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 静态属性


.dotaAll                // 是否开启 s 匹配模式
.global                 // 是否开启 g 匹配模式
.igonreCase             // 是否开启 i 匹配模式
.multiline              // 是否开启 m 匹配模式
.source                 // 返回当前的正则规则字符串( 不包括正则字面量两边的斜杠以及任何的标志字符 )



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## methods

### RegExp

#### RegExp.prototype.test();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * reg.test(target: string): boolean;
 * 
 * 
 * 验证某个字符串是否满足正则匹配的规则
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// .lastIndex               // 返回下一次匹配字符串开始的 索引位置


.test(); 匹配中开启全局匹配后

    若 上一次匹配成功，则会接着上一次的位置 继续匹配
    若 上一次匹配失败，则从头匹配


.test(); 匹配中默认不启用全局匹配，则每次匹配都是从头开始匹配


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 获取匹配次数
 * 
 * 
 */

let count = 0;

while(reg.test(string)) {

    count++;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### greedy match mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 默认贪婪匹配模式
 * 
 * 
 * 正则表达式去匹配时，会尽量多的匹配符合条件的内容
 */

+，?，*，{n}，{n,}，{n,m}                // 这些标识符，代表是贪婪匹配，会尽可能多的去匹配内容


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 非贪婪匹配模式
 * 
 * 
 * 量词后添加问号，表示取消贪婪模式         // 非贪婪模式，每次都是从头开始重新匹配
 * 
 * [range]{quantifier}?               // 量词? => 表示取消贪婪匹配
 */

reg??

{rag}?


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### RegExp.prototype.exec();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * reg.exec(target: string): array;
 * 
 * 
 * 执行一次 正则匹配
 * 
 * return: [
 *      0: 'result',                // 正则匹配到的结果
 *      gourps: undefined,          // 捕获组
 *      index: number,              // .lastIndex: 当次匹配从 目标字符串 的哪一位开始
 *      input: reg,                 // targetString: 目标字符串
 *      length: number,             // 
 * ];
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 获取所有匹配结果和位置

const reg = /reg/,
    targetStr = '';

while(true) {

    let resultArr = reg.exec(targetStr);
    
    if(result) {
        
        break;
    }
    
    console.log(`匹配结果: ${resultArr[0]}, 匹配位置${resultArr[index]}`);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### String

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.match(pattern: string | regexp): resultArr;
 * str.split(seperator: string | regexp, limit: int): string[];
 * str.search(pattern: string | regexp): firstIndex | -1;
 * str.replace(pattern: string | regexp, replacement: string | function): string;
 * 
 * 
 * String 方法中的参数若使用正则作为匹配方式
 * 
 * 则默认将 string 转换为 regexp  <===  new RegExp(string);
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### String.prototype.match();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.match(pattern: string | regexp): resultArr;
 * 
 * 
 * resultArr: [
 * 
 *      0: 'result',                // 匹配到的结构
 *      groupss: undefined,         // 捕获组
 *      index: 0,                   // regexp.lastIndex
 *      input: 'targetStr',         // 当前匹配的字符串
 *      length: number,
 * ]
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### String.prototype.search();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.search(pattern: string | regexp): firstIndex | -1;
 * 
 * 
 * 若匹配成功，则返回正则表达式在字符串中首次匹配项的索引，否则返回 -1
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### String.prototype.split();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.split(seperator: string | regexp, limit: int): string[];
 * 
 * 
 * @limit: 限定返回的分割片段数量
 * 
 * @seperator: 
 *      
 *      1) string: 
 *      
 *      2) regexp: 
 * 
 * 
 * 返回 以 分隔符( string | regexp ) 出现位置分隔而成的一个 Array<string>
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### String.prototype.replace();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.replace(pattern: string | regexp, replacement: string | function): string;
 * 
 * 
 * @replacement:
 *      
 *      1) string
 *      
 *      2) fuction(match){}: string;            // 全局模式:  match( 每次匹配成功的结果 )
 *                                              // 非全局模式: match( 仅当前匹配成功的结果 )
 * 
 * 根据 匹配规则 替换指定 字符，并返回一个新的字符串
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## extend

#### capture group

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 捕获组
 * 
 * 
 * 捕获组的匹配结果不会影响 正则匹配的结果
 * 
 * 捕获组匹配的结果会在返回的数组中依次单独存储
 */


// 单个捕获组
/(captureRegExp)/                       


// 多个捕获组
/(captureRegExp_01)(captureRegExp_02)(captureRegExp_03)/        


// 具名捕获组
/(?<captrueKey>captureRegExp)/

groups: {                       // 具名捕获组 key 与 匹配到的结果 val 会存放与 groups 中
    captrueKey: captureVal,
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 非捕获组
 * 
 * 
 * 仅将括号中的正则作为一个整体
 */

/(?:captureRegExp)/


//-------------------------------------------------------------------------------------------------------------------//


// 未使用 捕获组

/**
 * reg.exec(target: string): array;
 * 
 * 
 * 执行一次 正则匹配
 * 
 * return: [
 *      
 *      0: 'result',                        // 仅有正则匹配的结果
 *      
 *      gourps: undefined | object,         // 存放 有命名的捕获组的名称
 *      index: number,              
 *      input: reg,                 
 *      length: number,             
 * ];
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 使用 捕获组

/**
 * reg.exec(target: string): array;
 * 
 * 
 * 执行一次 正则匹配
 * 
 * return: [
 *      
 *      0: 'result',                        // 正则匹配的结果
 * 
 *      1: 'captrueResult_01',              // 捕获组依次匹配结果
 *      2: 'captrueResult_02',              // 捕获组依次匹配结果
 *      3: 'captrueResult_03',              // 捕获组依次匹配结果
 *      ...
 *      
 *      gourps: undefined,
 *      index: number,
 *      input: reg,
 *      length: number,
 * ];
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### replace of capture group

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * String.prototype.replace(); 中使用捕获组
 * 
 * 
 * 当使用捕获组匹配时，replace() 的第二个函数参数中从第二个参数开始，会接收 不同捕获组 依次匹配到的结果
 */


// 捕获组依次匹配到的结果会以 function(match, ...captureGroupVals){} 的第二个参数依次传递 
str.replace(
    /(captureGroupKey_01)(captureGroupKey_02)(captureGroupKey_03)/, 
    function(match, captureGroupVal_01, captureGroupVal_02, captureGroupVal_03)) {

        // @match: 整个正则匹配到的结果
        // @captureGroupVal_xx: 捕获组依次匹配到的结果
    };


// 特殊字符 $[i] 字符可以代表捕获组依次撇配到的结果
str.replace(/(key1)(key2)(key3)/, '$[1]$[2]$[3]')


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### back reference

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 反向引用
 * 
 * 
 * syntax: (captureGroup)\[index: int]
 * 
 *      @index: 捕获组索引，从左到右 从 1 开始递增( match[0] 为正则的返回结果 )
 * 
 * 
 * 用于修饰 "(captureGroup)/捕获组"
 * 
 * 反向引用提供查找重复字符组的方便的方法，被认为是再次匹配同一个字符串的快捷指令
 */


// 非具名反向捕获
/(captureGroup)\[index: int]{frequency}/


// 具名反向捕获
/(?<key>captureGroup)\k<[key]{frequency}>/


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/(reg)\1/                               // 匹配 regreg

/(reg)(exp)\1\2/                        // 匹配 regexp


/(?<k1>reg)(?<k2>exp)\k<k1>\k<k2>/      // 匹配 regreg


//-------------------------------------------------------------------------------------------------------------------//


// 获取去重后的字符串


const str = 'aaaaaaabbbbbbbbbcccccccceghllllll';

const newStr = str.replace(/(\w)\1+/g, '$1');

console.log(newStr);            // abceghl


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### 零宽断言

#### 正向断言

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 正向断言( 预查 )
 * 
 * 
 * /reg(?=reg)/
 * 
 * 
 * 检查某个字符串后的字符是否满足某个规则
 * 
 ** 断言的匹配规则仅用于约束正则的匹配规则，断言匹配的结果并不与正则匹配结果一同返回
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


const str = 'asd123sda123ad123dwad1231',
    reg = /[a-z]{3}(?=\d+)/g;

while (res = reg.exec(str)) {

	console.log(res);
    // ["asd", index: 0, input: "asd123sda123ad123dwad1231", groups: undefined]
    // ["sda", index: 6, input: "asd123sda123ad123dwad1231", groups: undefined]
    // ["wad", index: 18, input: "asd123sda123ad123dwad1231", groups: undefined]
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


const str = '21159310785071',
    reg = /\B(?=(\d{3})+$)+/g,
    res = str.replace(reg, ',');

console.log(res);           // 21,159,310,785,071


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 负向断言

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 负向断言( 预查 )
 * 
 * 
 * /reg(?=reg)/
 * 
 * 
 * 检查某个字符串后的字符是否不满足某个规则
 * 
 ** 断言的匹配规则仅用于约束正则的匹配规则，断言匹配的结果并不与正则匹配结果一同返回
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

const str = 'dwad21159310dwa785071',
    reg = /[a-zA-Z](?!\d+)/g;

while (res = reg.exec(str)) {

	console.log(res);

    // ["d", index: 0, input: "dwad21159310dwa785071", groups: undefined]
    // ["w", index: 1, input: "dwad21159310dwa785071", groups: undefined]
    // ["a", index: 2, input: "dwad21159310dwa785071", groups: undefined]
    // ["d", index: 12, input: "dwad21159310dwa785071", groups: undefined]
    // ["w", index: 13, input: "dwad21159310dwa785071", groups: undefined]
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### case

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 判断密码强度
 * 
 * 
 * 必须出现 大写字母，小写字母，数字，特殊字符(!@_,.)，并且 6 ~ 12 位
 */

// 思路分析: 
// 1. 先判读 正向断言: 起始位空字符 后是否有 "大写字母，小写字母，数字，特殊字符(!@_,.)"
// 2. 再判断 密码必须是 6 ~ 12 位

const pwd = 'dwa123dwad',
	reg = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#_,.]).{6,12}$/;

console.log(reg.test(pwd));         // false


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 根据不同规则判断密码强度 
 * 
 * 
 * 
 * 强: 大写字母，小写字母，数字，特殊字符(!@_,.)，必须是 6 ~ 12 位
 * 
 * 中: 大写字母，小写字母，数字，必须是 6 ~ 12 位
 * 
 * 弱: "大写字母和数字 或 小写字母和数字"，必须是 6 ~ 12 位
 */


function checkPasswordStrength(pwd) {

	if (/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#_,.]).{6,12}$/.test(pwd)) {

		return '强';

	} else if (/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{6,12}$/.test(pwd)) {

		return '中';

	} else if (/^((?=.*[a-z])(?=.*\d)|(?=.*[A-Z])(?=.*\d)).{6,12}$/.test(pwd)) {

        return '弱'

	} else {

		return '非有效密码';
	}
}

console.log(checkPasswordStrength('AAAA11111'));


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```