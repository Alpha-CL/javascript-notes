## desigin mode

### design mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 什么是设计模式
 * 
 * 
 * 可以被反复使用的代码经验
 */


1) 被多数人知晓

2) 经过分类

3) 代码设计经验的总结


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 使用设计模式的目的
 * 
 * 
 * 设计模式是 软件工程 的基础( 搭建骨架 )
 */


1) 降低代码耦合，更利于他人理解

2) 保证代码的可靠性

3) 以工程化的方式编写代码


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### create object

#### 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### structure model

#### 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### design principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 降低代码的复杂程度，合理的减少代码的耦合程度


1) 降低代码的耦合

2) 增强代码复用性

3) 降低代码的开发和维护成本


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 耦合关系


指某两个事物之间存在相互作用，相互影响的关系


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 耦合和复杂度的危害( 需要根据业务去平衡两者 )


复杂度高:

    - 代码质量不高
    
    - 可维护性差
    
    - 复用性差，不以扩哦


耦合度高: 无( 不可能 ) -> 低( 合理即可 )

    - 高: 不易维护，代码冗余
    
    - 低: 复用性/扩展性 好


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 开发流程


1) 平衡 复杂度 <==> 耦合度          // 优先降低 复杂度

    - 降低 负责度，则 耦合度增加
    
    - 复杂度 增高，则 耦合度降低


2) 通过 迪米特法则 减少耦合度

3) 通过 依赖倒置原则 消除可以没有的耦合


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 先原则，再模式


根据不同的业务，权衡利弊


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### principles

#### single responsibility principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 单一职责原则           // 纯函数
 * 
 * 
 * 一个方法仅做一件事
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### open close principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 开闭原则: 根据经验，为可能出现的 api 预留 扩展接口


1) 一个软件实体( eg: 类，模块，函数 )，应该对扩展开放，对修改关闭

2) 面向扩展开放，面向修改关闭

3) 同时增强代码复用性


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### l substitution principle 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 里氏替换原则


1) 子类可以 继承/扩展 父类的功能，但 子类 不能改变 父类 原有的功能

2) 子类 可以访问 父类的 接口


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### dimit principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 迪米特法则


1) 一个接口 对应 一个方法

2) 方法中参数尽量少( 避免被恶意拦截 )

3) 减少关联，降低依赖


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### dependency inversion principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 依赖倒置原则


1) 依赖接口，不依赖方法，降低耦合度

2) 将多者之间的依赖，提取出来，依赖公共的 变量/状态 等

3) js 中没有接口的概念


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### api principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 接口分离原则


将大接口拆分为小接口( 不要一个接口实现 增/删/改/查 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 根据不同的 请求方法 区分同一接口对应的操作


get         // 获取

post        // 提交

update      // 修改

delete      // 删除

...


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## 

#### singleton mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 单例模式


1) 保证一个类仅有一个实例

2) 并提供一个访问它的全局访问点


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


getSingle(func) {
    let result;
    if (!result) {
        result = func.apply(this, arguments);
    }
    return result;
}


//-------------------------------------------------------------------------------------------------------------------//


// 代理模式: 为一个对象提供一种代理，以控制对这个对象的访问


虚拟代理: 虚拟代理是把一些开销很大的对象，延迟到真正需要它的的时候才去创建执行

    - eg: 图片加载，文件上传 ...

安全代理: 控制真实对象的访问权限

    - eg: 控制真实对象的访问权限( 登陆后才能看全部功能，前段效验 )

远程代理: 一个对象将不同空间的对象进行局部代理

    - eg: 监控多个对象的状态，总机监控分店

智能代理: 调用对象代理处理另外一些事情如垃圾回收机制增加额外的服务

    - eg: 提供额外的其它服务，火车站代售处


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### strategy mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 策略模式


对一系列算法定义，并将每一个算法封装，使他们可以相互替换
策略模式让算法独立于使用它的客户而独立变化


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


策略模式支持运行时选择算法( 将算法封装起来，并使它们可以互相替换 )

决定用一个类对象实例来管理规则的效验

该对象要能相应的主动添加对规则的相应处理办法

效验数据的时候可以相应的返回相关信息


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

####

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

####

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```





















