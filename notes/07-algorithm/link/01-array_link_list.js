///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 算法导论


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 一纬数据解构
 *
 *
 * 线性的数据解构强调 存储 与 顺序
 *
 **     数组
 **     链表
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 数组 vs 链表
 *
 *
 *
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 数组特性
 *
 *
 * 1. 存储在物理空间上是连续的
 *
 * 2. 底层的数组长度是固定的
 *
 * 3. "arr数组" 的引用地址指向 "arr[0] 的地址"
 *    底层原理: "arr[i]" "通过 arr[0] 的地址偏移量查询的"          // 通过偏移查询水族性能最好
 */


// 数组的长度是不可变的, 扩容数组会申请新的内存空间( 操作系统会随机分配给你指定的大小的内存空间 )
// 再将之前的数据复制过来, 再添加新的数组子项


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 优点
 *
 *
 * 1. 查询性能好             // 根据指定索引查询子项时
 *                         // ( "数组引用地址 == 数组首项地址" -> "首项地址 + 偏移地址" -> "查询指定子项" )
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 缺点
 *
 *
 * 1. 因空间必须是连续的, 所以如果数组比较大, 则当系统空间碎片较多时, 可能会存不下
 *
 * 2. 因为数组的长度是固定的, 所以难以更改数组子项( 增加 / 删除 )            // 较为消耗性能
 *
 *
 ** 空间碎片: 数组中未使用的空置位置
 **         ( 整理空间: 将数组中的空间碎片进行整理, 较为消耗内存空间 )
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 单链表
 *
 *
 * 1. 空间上不是连续的
 *
 * 2. 每存放一个值,  都要多开销一个引用空间
 *
 ** 链表的传递必须是 链表的根节点( 链表中每个节点, 都认为自己是根节点 )
 */

let node_01,
    node_02,
    node_03;

const linkedList = [node_01, node_02, node_03];             // 模拟链表

node_01 = {                     // 每个节点仅记录 "当前节点的值" 和 "下一个节点的地址"
    value: 0,
    next: node_02               // 指向下一个节点
};
node_02 = {
    value: 1,
    next: node_03               // 指向下一个节点
};
node_03 = {                     // 最后一个节点指向 null 站位
    value: 2,
    next: null
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 优点
 *
 *
 * 1. 只要内存足够大, 就能存下             // 不用担心看空间碎片的问题
 *
 * 2. 链表的添加和删除相较于数组比较容易
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 缺点
 *
 *
 * 1. 查询速度慢( 根据位置查询: 根据节点的 next 查询 )
 *
 * 2. 链表的每个节点都需要创建一个指向 next 的引用( 浪费部分空间 )
 */


//-------------------------------------------------------------------------------------------------------------------//


function Node(value) {
    this.value = value;
    this.next = null;
}

let a = new Node(1),
    b = new Node(2),
    c = new Node(3),
    d = new Node(4);

a.next = b;
b.next = c;
c.next = d;
d.next = null;

console.log(a.value);
console.log(a.next.value);
console.log(a.next.next.value);
console.log(a.next.next.next.value);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
