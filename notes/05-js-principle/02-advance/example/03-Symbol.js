///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Symbol();                // 不能使用 new 创建
 *
 *
 * Symbol.iterator();       // 静态方法
 * Symbol.create();         // 警惕方法
 *
 *
 * 创建一个唯一的值
 *
 ** 解决问题: 代替之前语义话的私有属性 _personal
 */


let obj = {
    name: 'alpha',
    age: 18
}

Object.getOwnPropertySymbols(obj);              // 公开获得对象中的所有 symbol


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 通过原型调用系统构造函数的方法
 *
 *
 * ['build-in-class'].prototype.method
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 默认值: 对赋值来说, 将原型作为默认值
 *
 *
 ** ['build-in-fn'].prototype
 *      - 只会创建一次
 *      - 虽然可以作为默认值，但默认值会改变的话，则会更改原型，则不建议使用
 *
 ** [], {}, ... 作为默认值，赋值时若改变引用则会重新创建( 则之前赋值的默认值: CPU资源浪费 )
 */


console.log(Function.prototype);            // 空函数
console.log(RegExp.prototype);              // 空正则
console.log(Array.prototype);               // 空数组


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
