# syntax

#### basic concepts

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


statement: 句子
expression: 短语
operator: 连接词


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// statement vs expression

语句都有结果值, 表达式返回结果


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// statement

var a = 520;                // 控制台的每次调试返回的 undefined 是语句的结果
// undefined

es5 规范中 算法实际上都有返回值( 包含所声明变量名称的字符串 )
但这个值被变量语句算法屏蔽掉了( for... in ... 循环除外 )
最后返回为空 undefined


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### result of statement

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 语句的结果

{ ... }                     // 返回当前代码快中最后一个 语句/表达式 的结果


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


var b;

if (true) {

    b = 4 + 38;
}                           // 语句结果: 42


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// eval();                  // 避免使用: 作用域问题


var a, b;

a = eval('if(true) { b = 4 + 38}')

a;                          // 语句结果: 42


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// es7提案: do { ... }

执行一个代码块( 包含多个语句 ), 并返回其中最后一个语句的结果值，然后再赋值给变量


var a, b;

a = do {

    if (true) { b = 4 + 38}
}

a;                          // 语句结果: 42


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### side effects of expressions

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 表达式的副作用
 * 
 * 
 * 改变了不该改变的值
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


funcution foo() {
    a = a + 1;              // 改变了 a 的值
}

var a = 1;
foo();                      // undefined


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


var a = 520;
b = a++;                    // 先返回 a 的值, 再赋值给 b, 最后将 a 的值加 1


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// ( ... ) 并不能封装表达式，也不能使表达式在产生副作用之后再执行
// 仅提升运算优先级

var a = 520,
    b;

b = ( a++, a );             // a++, a 中第二个表达式 a 在 a++ 之后执行
                            // 结果为 521, 并赋值给 b

a;                          // 521
b;                          // 521


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


delete obj.prop: boolean;        // 删除对象的属性, 返回是否删除成功的布尔值
( 仅可删除 configurable 的属性 )


var obj = {
    a: 520
};

obj.a;                      // 520;
delete obj.a;               // true
obj.a;                      // undefined


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// a = 520 中 = 运算符看起来没有副作用, 实际上它的结果值是 520, 它的副作用是将 520 赋值给 a
( +=, -= 也同样有此副作用 )


var a;

a = 520;
a;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 链式赋值

var a, b, c;

a = b = c = 520;            // c = 520; ( 副作用是 c 赋值 520 )
                            // b = 520; ( 副作用是 b 赋值 520 )
                            // a = 520; ( 副作用是 a 赋值 520 )

若 b 在当前作用域中没有声明
    - 常规模式: b = undefined;
    - 严格模式: error
则 var a = b = c = 520; 不会对变量 b 进行声明
在严格模式中这样会产生错误


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### context

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

{ ... }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


//  大括号

var a = {                   // { ... } 被赋值给 a, 因而它是一个常量
    foo: bar()
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 标签: { ... } 和 for/while 循环以及 if 条件语句中代码块的作用基本相同 


{
    foo: bar()              // 标签语句
}


//-------------------------------------------------------------------------------------------------------------------//

json & jsonp

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// JSON: json 的属性名必须是 字符串
         ( 在控制台输入 { "key" : "val" } 会报错, 因为标签不允许使用 双引号
           所以 "key" 并不是一个合法的标签, 因此后面不能带 :               )

        * json 的确是 javascript 语法的一个子集, 但 json 本身并不是合法的 javascript 语法


{ "key" : "val" }           // js 中此中语法是不合法的
                            // 标签允许使用双引号, 所以 "key" 并不是合法的标签, 因此后面不能带:


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// JSON-P


{ "key" : "val" }               // 作为 json 没有问题, 但作为代码块执行会产生错误

jsonp({ "key" : "val" })        // 此时 json 作为参数传递, jsonp 会将 json 转换为 "合法的 javascript 语法"


//-------------------------------------------------------------------------------------------------------------------//

[ ... ]

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


[] + {};            // [object Object]


[] -> [].toString(); + {} -> '' + [object Object] -> '[object Object]'


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{} + [];            // 0


{} + [].toString -> ToNumber([]) -> 0           // {} 被当作独立的空代码块执行( 不做任何操作 )


//-------------------------------------------------------------------------------------------------------------------//

// 对象解构

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


const { prop } = obj;                           // 对象解构

if ( condition ) statement;                     // 当 if 语句代码块中 只有一条语句时，可以简写


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### operator priority

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


()  >  &&  >  ||  >  ?:  >  =


//-------------------------------------------------------------------------------------------------------------------//


var a = 520,
    b;

b = ( a++, a );

a;      // 521
b;      // 521


//-------------------------------------------------------------------------------------------------------------------//


var a = 520,
    b;

b = a++, a;

a;      // 521
b;      // 520


//-------------------------------------------------------------------------------------------------------------------//


// 若不是用 () 提升运算优先级, 则赋值运算会报错

if (str && ( match = str.match(/[aeiou]/g) )) {}


//-------------------------------------------------------------------------------------------------------------------//


// 短路语句

statement: true && statement;


//-------------------------------------------------------------------------------------------------------------------//


// 赋值语句

statement: false || statement;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### autocomplete semicolon asi

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * ASI           // 解析器错误( 代码中缺失了必要的分号 )
 * 
 * 
 * ASI 仅在换行处起作用, 不会在代码行中间插入分号
 */

ASI: 语法纠错机制( 提高解析器的容错性 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 必须以分号结尾

do ... while ... ;
for(;;){}
return ;
break ;
continue ;
yield ;
...


// 可以不需要以分号结尾

while
...


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### error

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


所有语法错误都是早期错误, 程序有语法错误则无法运行


//-------------------------------------------------------------------------------------------------------------------//


TypeError


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


ReferenceError

等号左边赋值时候产生的引用错误


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


SyntaxError


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//



early error             // 在编译阶段发现的代码错误


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


try ... catch ...


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### temporal dead zone

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 暂时性死区
 * 
 * 
 * 由于代码中的变量还没有初始化而不能被引用的情况
 */

必须先声明内存空间, 再使用

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{
    a = 2;              // ReferenceError
    let a;
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{
    typeof a;           // undefined
    typeof b;           // ReferenceError( TDZ )
    let b;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### default params of function

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 函数参数的默认值
 * 
 * 
 * es5/es6：参数默认值会导致 arguments 数组和相对应的命名之间出现了偏差
 *          不传递参数, 则不会建立关联
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


function foo(a =  520, b = a + 1) {

    console.log(
        arguments.length, 
        a, 
        b,
        arguments[0], arguments[1]
    );
}

// 虽然函数参数 a, b  都有默认值, 但函数不带参数时, arguments 数组为空

foo();                      // 0 520 521 undefined undefined
foo(10);                    // 1 520 521 520 undefined
foo(10, undefined);         // 2 520 521 520 undefined
foo(10, null);              // 2 520 null 520 null


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// es6: arguments 数组已被废弃
        引入剩余参数

不要同时访问 "命名参数" 和 "其对应的arguments数组单元"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### try ... catch ... & try ... finally ...

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * try ... catch/finally ...
 * 
 * 
 * 只要抛出错误, 则函数会在此终止
 */


finally 中的 return 会覆盖 catch 中的 return

执行优先顺序: try > catch > finally

通常在函数中省略 return 等效于 return undefined; 但是在 finally 中省略 return 则返回前面 return 的返回值

使用 continue, break 虽然可以跳过 return 但会使代码变得难以理解


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// try ... catch ...


try {

} catch {

}


//-------------------------------------------------------------------------------------------------------------------//


// try ... finally ...


try {

} finally {

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### switch

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 将 key 的值与 case 表达式进行比较, 若匹配成功则执行 case 中的代码, 直至 break 或 switch 代码结束

switch(key)

    case [originalValue]:           // 原始值: 直接匹配即可
    
    continue;                       // 
    
    case [expression]:              // 表达式: 避免出问题 !!(expression) 强制转换为 布尔值
    
    break;                          // 
    
    default:                        // 
    
    break;                          // 最后的 break 可省略
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### JavaScripts in a mixed environment

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// ECMAScriptx


在非严格模式中允许 八进制数值 常量存在

window.escape(); & window.unecape();

String.prototype.substr(start, end); & String.prototype.substring(start, length);


//-------------------------------------------------------------------------------------------------------------------//


// Web ECMAScript


<!-- ... --> 是合法的单行注释分隔符

String.prototype 中返回 HTML 格式的附加方法: anchor(), big(), blink(), bold(), fixed(), blod(),
fixed(), fontcolor(), fontsize(), italics(), link(), small(), strike(), sub() ...
    
RegExp: RegExp.$1, RegExp.$9, RegExp.lastMatch/RegExp['$&']

funcution.prototype: Function.prototype.arguments( arguments )
                     Function.call( arguments.caller )


//-------------------------------------------------------------------------------------------------------------------//


// 宿主对象

var dom = document.createElement('div');

typeof dom;                                     // 'object'

Object.prototype.toString.call(a);              // '[object HTMLDivElement]'


dom 不仅仅是一个特殊的宿主对象, 它是一个 DOM 元素
其内部的 [[class]]: 'HTMLDivElement'             // 内置属性, 通常只读不可更改


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 其他酥组合对象的行为差异


无法访问正常的 object 内置方法，eg: toString();

无法覆盖内置方法

包含一些预定义的只读属性

其他 ...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// console 

浏览器: 输出到开发工具控制台

服务器: 指向 javascript 环境系统进程的标准输出( stdout & error)


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
















