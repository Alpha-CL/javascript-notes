#

#### create object

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// {} vs new Object();


{} 可以直接添加多个 键/值对

new Object(); 只能逐个添加属性


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 设计缺陷

(typeof null): object;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### object

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// typeof 原理

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


不同的对象底层都表示为二进制
在 javascript 中二进制前三位 都为 0 的话会被判断为 object 类型
( null 的二进制表示为 0,  typeof null: object )


//-------------------------------------------------------------------------------------------------------------------//

// 包装类

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


包装类: 当原始值使用方法时, js 会自动将原始类进行构造，当使用完属性和方法后会自动销毁
( null & undefined 没有对应的构造形式 )

eg: str.length; 


//-------------------------------------------------------------------------------------------------------------------//


Object, Aarray, Function，Regexp, Error 无论是文字形式还是构造形式，都是对象，不是字面量


//-------------------------------------------------------------------------------------------------------------------//

// 对象成员访问方式

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) str.member               // 直接访问成员

2) str['member']            // 可以访问 UTF-8/UUnicode 属性名的成员


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### clone

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// shade clone

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 因使用 = 操作符赋值，则源对象属性的 一些特性( eg: writeable ) 不会被复制到目标对象

var newObj = Object.assign({}, myObject);


//-------------------------------------------------------------------------------------------------------------------//

// deep clone

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 使用前提: 必须保证目标是 JSON

var newObj = JSON.parse(JSON.stringify(someObj));


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

```

#### array as object

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 数据也是对象
 * 
 * 
 * 数组有一套更加结构化的值存储机制
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 可以为数组添加命名属性，但不会改变数组长度


var arr = ['foo', 2, 'bar'];


arr.length;             // 3

arr.baz = 'baz';        // 数组也是对象，虽然每个下标都是整数，依然可以给数组添加属性，但不会改变数组的长度

arr.length;             // 3


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Object.defineProperty();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 属性描述符


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


对象: 

    - 键值对 集合
    
    - 获取方法 obj.member & obj['member']
    
        * 通过调用该成员的 getter/setter 操作该属性


//-------------------------------------------------------------------------------------------------------------------//


var obj = {};

Object.defineProperty(obj, 'a', {
    
    value: 2,
    writeable: true,                    // 是否允许( 修改属性: 是否只读 )
    configurable: false,                // 是否允许( 可配置: 是否允许修改修饰符配置 )
    enumerable: true,                   // 是否允许( 枚举: 是否可循环 )
});



// writeable

// configurable

// enumerable


//-------------------------------------------------------------------------------------------------------------------//


// 禁止对象添加新属性，并保留当前已有的属性


Object.seal(); 

原理: 使用 Object.preventExtensions(); 将现有属性标记为 configurable: false; 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 冻结一个对象

Object.freeze();

原理: 调用 Object.seal(); 


//-------------------------------------------------------------------------------------------------------------------//


// 当给一个属性定义 getter setter 时，则该属性被定义为 "访问描符"
   ( getter & setter 会在调用该属性和设置该属性时调用 )


对于访问符，javascript 会忽略它们的 value & writeable  特性

则关注: get, set, configurable, enumerable


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// getter



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// setter



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### relation

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 当访问对象的属性时，返回 undefined 该如何判断？

    1) 该值存储的为 undefined
    
    2) 该值不存在


//-------------------------------------------------------------------------------------------------------------------//


/**
 * ('prop' in obj): boolean;
 * 
 * 
 * 判断该属性是否在其 prototype( 原型链 ) 中
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * obj.hasOwnProperty('prop')：boolean;
 * 
 * 
 * 判断该属性是否在其 对象 中
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 除了以下情况，所有的普通对象都可以通 Object.defineProperty(); 判断


若通过 Object.create(null)；

则需要 Object.prototype.defineProperty.call(obj, 'a'); 


//-------------------------------------------------------------------------------------------------------------------//


/**
 * obj.propertyIsEnumerable('prop')：boolean;
 * 
 * 
 * 判断该属性是否直接存储在其对象中( 而不是在原型链中 )
 * 并且满足 {enumerable: true}
 */


//-------------------------------------------------------------------------------------------------------------------//


Object.keys(obj): arr;                          // 返回所有可枚举的属性名

Object.getOwnPropertyNames(obj): arr;           // 返回所有属性名( 无论是否可枚举 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### enumerable

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// for

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 使用 for 循环遍历: 是遍历数组的下标指向值


var arr = [1, 2, 3];

for(var i = 0; i< arr.length; i++) {
    
    console.log(arr[i]);
}


//-------------------------------------------------------------------------------------------------------------------//

// for ... in ...

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 用于遍历对象中所有可枚举的属性，获取属性值需要通过 obj[prop] 来访问


var obj = { a: 1, b: 2, c: 3}

for(let prop in arr){

    const val = arr[prop];
}


//-------------------------------------------------------------------------------------------------------------------//

// for ... of ...

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 用于遍历 数组/对象 中可枚举属性的值


var arr = [1, 2, 3];

for(let val in arr) {

    console.log(val);
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 向被访问对象请求一个迭代器( next(); )，再通过迭代器对象的 next()

var obj = {a : 1, b : 2, c : 3}，
    it = obj[Symbol.iterator]();


it.next();          // { value: 1, done: false }
it.next();          // { value: 2, done: false }
it.next();          // { value: 3, done: false }
it.next();          // { done: false }


Symbol.iterator = function () {         // 一个返回迭代器对象的函数
    ...
    return function next() {
        return {
            value: '',
            done: boolean
    }
}


//-------------------------------------------------------------------------------------------------------------------//

// forEach();

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


var arr = [1, 2, 3];

arr.forEach(val => {

    console.log(val);
})


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### @iterator

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


var obj = {
    a: 1,
    b: 2,
    c: 3
};


Object.defineProperty(obj, Symbol.iterator, {

    enumerable: false,
    writeable: false,
    configurable: true,
    value: function() {
        
        var that = this,
            i = 0,
            allKeys = Object.keys(that);
        
        return {
            next: function() {
                return {
                    value: that[allKeys[i++]],
                    done: (i > ks.length)
                }
            }
        }
    }
});


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 手动调用对象的 迭代器

let myIterator = obj[Symbol.iterator];

myIterator.next();      // {value: 1, done: false}
myIterator.next();      // {value: 2, done: false}
myIterator.next();      // {value: 3, done: false}
myIterator.next();      // {value: undefined, done: true}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// for ... of ...

for (let val of obj) {

    console.log(val);
}

// 1
// 2
// 3


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Object.defineProperty + @@iterator

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Object.defineProperty + @@iterator
 * 
 * 
 * 利用属性描述 和 自定义描述器 可以作出很多好玩的功能
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 每次调用都会返回一个随机数( 因为 done: true，会造成死循环 )

var random = {

    [Symbol.iterator]: funcution() {
    
        return {
            
            next: function() {
                
                return: { value: Math.random() }
            }
        }
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

