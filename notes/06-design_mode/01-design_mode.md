## design mode

###

#### introduction

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 为什么要学习设计模式
 * 
 * 
 * 因为 js 语言的 特性 和 其灵活性, 允许以任何方式完成同样的任务
 */


- 函数式编程

- 面向对象编程

- ...


//-------------------------------------------------------------------------------------------------------------------//


// 1.0


function startAnimation () {

}

function stopAnimation () {

}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 1.1.1

let Animation = function () {

};

Animation.start = function () {

};

Animation.stop = function () {

};


let anim = new Animation();

anim.start();
...
anim.stop();


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 1.1.2


let Animation = function () {

};

Animation.principle.start = function () {

};

Animation.prototype.stop = function () {

};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 1.2.1


Function.prototype.method = function(name, fn) {

    this.prototype[name] = fn;
}

let Animation = function () {};

Animation.method('start', function () {});
Animation.method('stop', function () {});


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 1.2.2

Function.prototype.method = function(name, fn) {

    this.prototype[name] = fn;
    return this;
}

let Animation = function () {};

Animation.method('start', function () {});
Animation.method('stop', function () {});


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### weak type

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 弱类型语言

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 原始值: string, number( 不区分 int, float ), boolean，null, undefined

    - toString();                           // 转换为 字符串
    
    - parseInt(); & parseFloat();           // 转换为 数字
    
    - !![num];                              // 转换为 布尔值
 

// 引用值: object ( array, funcution )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 变量的数据类型类型: 


1) 定义变量时不必声明其数据类型

2) 原始值之间可以 类型转换( 强制 / 隐式 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### design mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 什么是设计模式
 * 
 * 
 * 可以被反复使用的代码经验
 */


1) 被多数人知晓

2) 经过分类

3) 代码设计经验的总结


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 使用设计模式的目的
 * 
 * 
 * 设计模式是 软件工程 的基础( 搭建骨架 )
 */


1) 降低代码耦合，更利于他人理解

2) 保证代码的可靠性

3) 以工程化的方式编写代码


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### first class member of func

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 函数是一等对象

    匿名函数
    
    函数表达式
    
    立即执行函数
    
    回调函数

    函数参数


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### object in javascript

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 对象的易变性
 * 
 * 
 * js 中除了( string, number, boolean) 基本上都是对象
 * 这三种类型在需要的时候也会自动隐式转换为对象
 */


//-------------------------------------------------------------------------------------------------------------------//


// Person class

funcution Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype = {
    getName: funcution() {
        return this.name;
    },
    getAge: funcution() {
        return this.age;
    }
}


// Instantiate the class

let alpha = new Person('alpha', 18),
    beta = new Person('beta', 17);


// Modify the class: 创建实例后，再向构造函数的原型链上添加方法，依然可以被实例对象使用

Person.prototype.getGreeting = function () {            // 反射
    return 'hi' + this.getName() + '!';
}

// Modify a specific instance

alpha.displayGreeting = function () {
    alert(this.getGreeting);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### why use design patterns

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) 可维护性

    设计模式有助于降低模块之间的耦合度


2) 沟通

    设计模式在处理不同类型的对象中采用同样的术语( eg: 工厂模式 ... )


3) 性能

    选择适当的设计模式可以有效提高成宿的运行速度, 并减少需要传送到客户端的代码量


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 复杂度 vs 性能


复杂度:

获得易维护性的代码，往往会增加代码的复杂度, 不易于理解


性能: 根据不同的业务选择合适的设计模式

通常设计模式都会相对降低代码的执行性能，但都可以接受


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```








### create object

#### 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### structure model

#### 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### design principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 降低代码的复杂程度，合理的减少代码的耦合程度


1) 降低代码的耦合

2) 增强代码复用性

3) 降低代码的开发和维护成本


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 耦合关系


指某两个事物之间存在相互作用，相互影响的关系


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 耦合和复杂度的危害( 需要根据业务去平衡两者 )


复杂度高:

    - 代码质量不高
    
    - 可维护性差
    
    - 复用性差，不以扩哦


耦合度高: 无( 不可能 ) -> 低( 合理即可 )

    - 高: 不易维护，代码冗余
    
    - 低: 复用性/扩展性 好


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 开发流程


1) 平衡 复杂度 <==> 耦合度          // 优先降低 复杂度

    - 降低 负责度，则 耦合度增加
    
    - 复杂度 增高，则 耦合度降低


2) 通过 迪米特法则 减少耦合度

3) 通过 依赖倒置原则 消除可以没有的耦合


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 先原则，再模式


根据不同的业务，权衡利弊


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### principles

#### single responsibility principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 单一职责原则           // 纯函数
 * 
 * 
 * 一个方法仅做一件事
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### open close principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 开闭原则: 根据经验，为可能出现的 api 预留 扩展接口


1) 一个软件实体( eg: 类，模块，函数 )，应该对扩展开放，对修改关闭

2) 面向扩展开放，面向修改关闭

3) 同时增强代码复用性


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### l substitution principle 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 里氏替换原则


1) 子类可以 继承/扩展 父类的功能，但 子类 不能改变 父类 原有的功能

2) 子类 可以访问 父类的 接口


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### dimit principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 迪米特法则


1) 一个接口 对应 一个方法

2) 方法中参数尽量少( 避免被恶意拦截 )

3) 减少关联，降低依赖


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### dependency inversion principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 依赖倒置原则


1) 依赖接口，不依赖方法，降低耦合度

2) 将多者之间的依赖，提取出来，依赖公共的 变量/状态 等

3) js 中没有接口的概念


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### api principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 接口分离原则


将大接口拆分为小接口( 不要一个接口实现 增/删/改/查 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 根据不同的 请求方法 区分同一接口对应的操作


get         // 获取

post        // 提交

update      // 修改

delete      // 删除

...


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## 

#### singleton mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 单例模式


1) 保证一个类仅有一个实例

2) 并提供一个访问它的全局访问点


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


getSingle(func) {
    let result;
    if (!result) {
        result = func.apply(this, arguments);
    }
    return result;
}


//-------------------------------------------------------------------------------------------------------------------//


// 代理模式: 为一个对象提供一种代理，以控制对这个对象的访问


虚拟代理: 虚拟代理是把一些开销很大的对象，延迟到真正需要它的的时候才去创建执行

    - eg: 图片加载，文件上传 ...

安全代理: 控制真实对象的访问权限

    - eg: 控制真实对象的访问权限( 登陆后才能看全部功能，前段效验 )

远程代理: 一个对象将不同空间的对象进行局部代理

    - eg: 监控多个对象的状态，总机监控分店

智能代理: 调用对象代理处理另外一些事情如垃圾回收机制增加额外的服务

    - eg: 提供额外的其它服务，火车站代售处


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### strategy mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 策略模式


对一系列算法定义，并将每一个算法封装，使他们可以相互替换
策略模式让算法独立于使用它的客户而独立变化


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


策略模式支持运行时选择算法( 将算法封装起来，并使它们可以互相替换 )

决定用一个类对象实例来管理规则的效验

该对象要能相应的主动添加对规则的相应处理办法

效验数据的时候可以相应的返回相关信息


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
