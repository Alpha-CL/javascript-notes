# JavaScript Number Extend

__JS 中的小数运算是精确的吗？__

``` javascript

不一定


```

__JS 中的整数运算是精确的吗?__

``` javascript


不一定


```

__JS 中表示的整数是连续的吗?__

``` javascript


不是，当 JS 的数很大的时候，不再连续 


```

__JS 中表示的最大数字是多少？__

``` javascript


最大连续整数 Number.MAX_SAFE_INTEGER


```

__JS 中能表示的数字有效位数是多少__

``` javascript


16 ~ 17


```

#### 数字进制

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


现实中: 十进制( 逢十进一 )

电脑中: 二进制( 逢二进一 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 二进制 -> 十进制
 * 
 */

1           1           0           1                       // 1101( 二进制 ) -> 十进制

1 * 2 ^ 3   1 * 2 ^ 2   0 * 2 ^ 1   1 * 2 ^ 0               // 13


1           1           .0              1                   // 11.01( 二进制 ) -> 十进制

1 * 2 ^ 1   1 * 2 ^ 0   0 * 2 ^{ -1 }   1 * 2 ^ { -2 }      // 2.25


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 十进制 -> 二进制
 * 
 * 
 */


13 / 2      商 6     余 1                                     // 13( 十进制 ) -> 二进制

6 / 2       商 3     余 0 

3 / 2       商 1     余 1 

1 / 2       商 0     余 1                                     // 1011


余数 从上至下 及为 转换为二进制的结果


3 / 2       商 1     余 1                                     // 3.24( 十进制 ) -> 二进制 

1 / 2       商 0     余 1

0.25 * 2    0.5     数据部分 0

0.5 * 2     1.0     数据部分 1                                 // 11.01


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 为什么 JS 中小数运算不精确

十进制小数 转 二进制后，可能是无限小数

因计算机对数字的存储能力有限，所以会丢失一部分数据，才会造成 JS 小数运算的精准

``` javascript


0.3( 十进制 ) -> 二进制: 0.0100110011001 ...


0.3 * 2     0.6         0
0.6 * 2     1.2         1
0,2 * 2     0.4         0
0.4 * 2     0.8         0
0.8 * 2     1.6         1
0.6 * 2     1.2         1
0.2 * 2     0.4         0
...


```

#### JS 中如何存储数字

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * JS 中存储所有数字，都是按照浮点法存放的
 * 
 * 浮点法存放的数字，称为 浮点数( float )，浮点数分为 单精度 和 双精度( 双精度比单精度存储的小数位更多 )
 * 
 * JS 中，使用 双精度存放浮点数，IEEE 754
 */

var integer = 1000,
    float = 1.99;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * JS 在计算机中，给每个数字开辟了一块内存空间( 固定尺寸为 64 位 )
 * 
 */


在计算机中 ( bit ) 为最小存储单位，简称 bit


1 byte  =   8 bit

1 KB    =   1024 byte

1 MB    =   1024 KB

1 GB    =   1024 mb


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


64 bit

第一段      第二段             第三段

[1]        [2~12]            [13~64]


第一段: ( 1 位 ) 表示符号位，如果是 1，则是负数，如果是 0，则是正数

第二段: ( 11位 ) 表示指数位，这里的指数是以 2 为底的指数，而不是 10

第三段: ( 52位 ) 表示有效数字


// 11 位置的 二进制 可以表示多少个数字

1 位     2 ^ 1           2
1 位     2 ^ 1           4
1 位     2 ^ 1           8
...

11 位    2 ^ 11          2048


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


64 bit

第一段      第二段             第三段

[1]        [2~12]            [13~64]

0          1000 0000 011     1111 0000 0000 0000 ...


1000 0000 011   => 1027( 十进制 )

2048 / 2        => 1023( 约等于一半 )


1.111 * 2 ^ { 1027 - 1023 }


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 特殊情况
 * 
 * 正常数字，指数部分最多是 2046 -> 1111 1111 110
 */

1. 指数为 0，尾数为 0，表示数字 0
2. 符号为 0，指数为 2047，尾数为 0，表示 Infinity
3. 符号为 1，指数为 2047，尾数为 0，表示 -Infinity
4. 指数为 2047，尾数不为 0，表示 NaN


第一段      第二段             第三段

[1]        [2~12]            [13~64]

0          1111 1111 111     0000 0000 0000 0000 ...            // Infinity

1          1111 1111 111     0000 0000 0000 0000 ...            // -Infinity

1          1111 1111 111     0100 1100 0000 0000 ...            // NaN

0          1111 1111 111     0100 1100 0000 0000 ...            // NaN



// 能表示的最大数字

0          1111 1111 111     1111 1111 1111 1111 ...            

=> 1.1111 1111 ... * 2 ^ { 2046 - 1023 } == NUmber.MAX_VALUE



// 能表示的最大安全数字

( 安全数字，从 1 开始到该数字，均是连续的整数，并且该数字的下一个整数是存在的 )

0          xxxx xxxx xxx     1111 1111 1111 1111 ...   

=> 1.1111 1111 ... * 2 ^ 53 

=> 11111 1111 ...( 53 bit ) * 2


99          10 * 2 -1

999         10 * 3 -1

9999        10 * 4 -1

...

11111 1111 ...( 53 bit )        2 ^ 53 - 1                      // Number.MAX_SAFE_INTEGER


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
