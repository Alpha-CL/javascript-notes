# data type introduction

#### stack & heap

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// stack( 栈内存的简称 )

为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型
要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的原始类型之一，即 Undefined、Null、Boolean、Number 和 String 型
由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) 存储 原始数据类型                  

2) 按值访问              

3) 存储的值大小固定                 

4) 由系统自动分配内存空间                

5) 主要用来执行程序                   

6) 空间小, 运行效率高                 

7) 先进后出( first in, last out )


//-------------------------------------------------------------------------------------------------------------------//


// heap( 堆内存的简称 )


如果一个值是引用类型的，那么它的存储空间将从堆中分配
由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度
相反，放在变量的栈空间中的值是该对象存储在堆中的 "地址"
地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) 存储引用数据类型

2) 按引用访问

3) 存储的值大小不定，可动态调整

4) 由 程序猿 通过代码进行分配

5) 主要用来存放对象

6) 空间大、但是运行效率相对较慢

7) 无序存储，可根据引用直接获取


//-------------------------------------------------------------------------------------------------------------------//


         originValue                 referenceValue                                
         
        +            +               +            +
        |            |               |            |
        |  ... ...   |               |  ... ...   |
        |            |               |            |
        | undefined  |               |   Date     |
        |  address   + ----- +       |   Error    |
        |   false    |       |       |  Function  |
        |    996     |       |       |   Array    |
        |  "string"  |       + ----> |   Object   |
        + ---------- +               + ---------- +
            stack                         heap


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


1) 数据: 有用的信息

2) 数据类型: 数据的分类

3) 直接书写的具体的数据，称为 '子面量'


//-------------------------------------------------------------------------------------------------------------------//


// original value

    - number
    
    - string
    
    - boolean


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// reference value

    - object
    
    - array
    
    - function


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// other

    - null
    
    - undefined


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// es6

    - symbol
    
    - bigint


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


模拟初始化数据存储
    
|      stack         |       heap       | 
| ------ | --------- | ------ | ------- |
| 1011   |   text    | 1001   | text    |
| 1010   |   text    | 1002   | text    |
| 1009   |   text    | 1003   | text    |
| 1008   |   text    | 1004   | text    |
| 1007   |   text    | 1005   | text    |
| 1006   |   text    | 1006   | text    |
| 1005   |   text    | 1007   | text    |
| 1004   |   text    | 1008   | text    |
| 1003   |   text    | 1009   | text    |
| 1002   |   text    | 1010   | text    |
| 1001   |   text    | 1011   | text    |


模拟数据存储原理，及逻辑关系

|           |  stack    |           heap           | 
| stkname   | stkvalue  | hpadress   | hpcontent   |  
| --------- | --------- | ---------- | ----------- |
|           |           |            |             |  
| varname1  | number    | objadress  | object      |  
| varname2  | string    | 1002	     | text        |  
| varname3  | boolean   | 1003	     | text        |  
| varname4  | objadress | 1004	     | text        |  
| 1007      | text      | 1005	     | text        |  
| 1006      | text      | 1006	     | text        |  
| 1005      | text      | 1007	     | text        |  
| 1004      | text      | 1008	     | text        |  
| 1003      | text      | 1009	     | text        |  
| 1002      | text      | 1010	     | text        |  
| 1001      | text      | 1011	     | text        |  


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// dynamically typed language( 动态类型 ): 变量可被用于指向不同的数据类型

var x;           // now x is undefined
x = 5;           // now x is a number
x = "john";      // now x is a string


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## 原始值( 存放于栈内存中 ): 不可改变的原始值，除非数据覆盖( 内存满了 )

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * original value
 * 
 * 
 * 原始值是不具有属性或方法的值
 * 原始数据类型为具有原始值的数据
 */


//-------------------------------------------------------------------------------------------------------------------//


| value      | type             | description       |
| ---------- | ---------------- | ----------------  |
| "hello"    | string	        | “你好”总是“你好”    |
| 3.14	     | number	        | 3.14总是3.14       |
| true	     | boolean	        | 真正的永远是真       |
| false	     | boolean	        | 假的永远是假的       |
| null	     | null (object)    | 空总是空            |
| undefined  | undefined	    | 未定义总是不确定     |


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 原始值不能添加 属性或方法
  ( 隐式调用系统构造函数形成包装类后可以添加属性或方法 )


var str = "alpha";

str.length = 3;         // new Number(4).length; -> 原始值不具有属性 -> delete str.length;

console.log(str);       // "alpha"


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 仅在使用期间隐式调用系统构造函数

str.length; -> String(str).length


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### typeof

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * typeof [data] => type(origin-value | object)
 * 
 * 
 * 返回 原始值 或 引用值
 */


* javascript 是一种动态类型语言( dynamically typed language )

* 这意味着你在声明变量时可以不必指定数据类型

* 而数据类型会在代码执行时会根据需要自动转换


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) 原始值: 不可改变的原始值

    - string

    - number

    - boolean
    

2) 引用值: 

    - object
    
        - null: 早期用于 `代替空对象`，属于历史遗留问题
        
        - function
    
        - array
        
        - data


3) 其他数据类型

    - undefined


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


typeof "john"              // returns "string"
typeof 3.14                // returns "number"
typeof true                // returns "boolean"
typeof false               // returns "boolean"
typeof x                   // returns "undefined" (if x has no value)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### Number

#### basic

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


javascript `不会定义不同类型` 的数字，例如整数，短整数，长整数，浮点数等

遵循国际 ieee 754 标准，javascript 数字始终存储为 `双精度浮点数`

此格式以64位存储数字，其中数字（分数）存储在0到51位中，指数存储在52到62位中，而符号存储在63位中：


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


| 值(又称分数/经度） | 指数               | 标志             |
| ----------- ---- | ------------------ | --------------- |
| 52位（0-51）      | 11位（52-62）       | 1位（63）        |


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### precision

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


整数（ 不带句点或指数表示法的数字 ）的精度最高为15位数字

小数位数的最大值是 17，但是浮点算术并不总是 100％ 准确的


//-------------------------------------------------------------------------------------------------------------------//


var x = 999999999999999;        // x will be 999999999999999
var y = 9999999999999999;       // y will be 10000000000000000

var x = 0.2 + 0.1;              // x will be 0.30000000000000004


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### number & string

``` javascript
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


js 将 '+( 运算符 )' 用于 '加法' 和 '串联'


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


var x = 10;
var y = 20;
var z = x + y;           // z will be 30 ( a number )


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


var x = "10";
var y = "20";
var z = x + y;           // z will be 1020 (a string)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 无穷

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


infinity / -infinity 是如果您计算的数字超出最大可能数，javascript 将返回的 值

typeof infinity => number

typeof -infinity => number


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 进制原理

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


二进制: 遇 2 进 1

* 00000001 ------ 1
* 00000010 ------ 2
* 00000011 ------ 3
* 00000100 ------ 4
* 00000101 ------ 5
* 00000110 ------ 6

八进制: 遇 8 进 1

* 00000001 ------ 1
* 00000010 ------ 8
* 00000018 ------ 16

十进制: 遇 10 进 1

* 00000001 ------ 1
* 00000010 ------ 20
* 00000011 ------ 21

十六进制: 遇 f 进 1

* 00000001

    ...

* 00000009
* 0000000a ------ 10
* 0000000b ------ 11
* 0000000c ------ 12
* 0000000d ------ 13
* 0000000e ------ 14
* 0000000f ------ 15 // 遇 f 进 1
* 00000010 ------ 16


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 进制表示方法

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


* 十进制: 正常数字

    var integer = 10;
 
* 八进制: 以 0o 开头

    var _8octal = 0o12;

* 十六进制: 以 0x 开头

    var _160o12 = 0x12;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### String

#### introduction

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * String
 * 
 * 
 * 字符串用来存储和处理文本
 */


1) 必须用 '单引号' 或者 "双引号" 括起来

2) 若需要在字符串中使用引号等特殊符号，需要通过 `\` 字符转译


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

####  

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 字符串可以是对象


1) '不要创建字符串' 为 '对象'，会'减慢执行速度'

2) 'new' 关键字的代码复杂化，这可能会产生一些意想不到的结果

3) '==' 时，值相等；'===' 时，因为数据类型是 object，'无法比较对象'


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 字符串是 原始值，使用子面量创建
var firstname = "alpha";


// 字符串也可以使用 new 新建
var firstname = new string("alpha");


// 模版字符串 ``

`可保留

    ${javascript express}       // 可以直接插入变量或表达式，相比原始字符串拼劲更加方便，易懂

换行`


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### character translation

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 转义字符

| code | result | description |
| ---------------- | ----------------- | ---------------- |
| \\" |	" |	single quote |
| \\" |	" |	double quote |
| \\\ |	\ |	backslash |


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


| code | result | 
| ---------------- | ----------------- |
| \b |	backspace |
| \f |	form feed |
| \n |	new line |
| \r |	carriage return |
| \t |	horizontal tabulator |
| \v |	vertical tabulator |


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 字符串的类型

//-------------------------------------------------------------------------------------------------------------------//


// 值相等

var x = "alpha";                    

var y = new string("alpha");


if(x == y) {                        // true
    
   console.log("x and y have equal value");
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

// 类型不同


var x = "alpha";                    // string

var y = new string("alpha");        // object



if(x === y) {                       // false
   
  console.log("x and y have different types (string and object));
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 不同的 object 无法相比


var x = new string("alpha");        // object

var y = new string("alpha");        // object


if(x === y) {                       // false
   
  console.log("x and y are different objects");
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### boolean

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 只有两个值: 

    - true( 1 )

    - false( 0 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 大多判断都是用 boolean 类型判断

    - 除了这六个类型( 0、""、null、undefined、NaN、false )转换为 false
    
    - 其他都是 true


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### null

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 设置数据为空时为: null

null 为 object 类型


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### undefined

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


1) 变量声明未赋值，结果为 undefined

2) 函数没有明确返回值，如果接收了，结果也是 undefined

3) 如果一个变量的结果是 undefined 和一个数字进行计算，结果是 not a number ( NaN ), 也没有意义

    - var num;
    
    - console.log(num + 10); ==> // NaN


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


//没有值的变量，值和类型都是: undefined

var car;    // value is undefined, type is undefined


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### undefined vs null

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// `undefined `和 `null` 值相等 ，但`类型不同`


typeof undefined           // undefined
typeof null                // object

null === undefined         // false
null == undefined          // true


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## 引用值( 存放于堆内存中 ): array, object, function, date

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// typeof 可以返回两个复杂类型中的一种

    - function
    
    - object


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


typeof {name:"john", age:34} // returns "object"
typeof [1,2,3,4]             // returns "object" (not "array", see note below)
typeof null                  // returns "object"
typeof function myfunc(){}   // returns "function"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### Object

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


1) 必须用 `{}` 包裹

2) 数组项之间用`逗号隔开`

3) 最后一个项之后可以省略 `逗号`


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 子面量方式创建对象

var person = {

    firstname: "john", 
    lastname: "doe", 
    age:50, eyecolor:"blue"
    
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### Array

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * array
 * 
 * 
 * 数组是一种特殊类型的对象。在 typeof javascript 中操作返回数组“对象”
 */

array 对象主要用于将多个值存储在一个单可变结构

阵列索引从零开始：所述阵列中的第一个元素是 0，第二个为 1 ...


1) 必须用 `[]` 包裹

2) 数组项之间用`逗号隔开`

3) 最后一个项之后可以省略 `逗号`

4) javascript `不支持` 关联数组


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 子面量方式创建数组

var cars = [

    "saab",
    "volvo",
    "bmw"
];


// new 方式实例化数组

var cars = new Array(

    "saab", 
    "volvo", 
    "bmw"
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


var cars = ["saab", "volvo", "bmw"];
document.getelementbyid("demo").innerhtml = cars[0];


// 更改数组中第一个元素
var cars = ["saab", "volvo", "bmw"];
cars[0] = "opel";

document.getelementbyid("demo").innerhtml = cars[0];        // opel


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### array vs object

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


1) array(); 使用 `数字索引`

2) object{}; 使用 `字符串( 文本 )索引`


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### [] vs new Array();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


var arr1 = [66];

console.log(arr1[0]);           // 66


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// new array(length: number); => 设置新数组的 数组长度，而不是创建数组的第一项

var arr = new array(99);        // 定义一个长度为 40 的空数组

console.log(arr[0]);            // undefined
console.log(arr.length);        // 99


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### is array

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// method-01: ecmascript 5 定义了一个新的方法 `Array.isArray();`

Array.isArray(fruits): boolean;


//-------------------------------------------------------------------------------------------------------------------//



// method-02: 创建自己的 isArray();


function isarray (arr) {

    return arr.constructor.toString().indexof("array") > -1;          // return ture
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// method-03: `instanceof` 对象是否是由给定的构造函数创建运算符返回 true


var fruits = ["banana", "orange", "apple", "mango"];

fruits instanceof array;            // return ture


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### Function

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### Data

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## 垃圾回收

#### what is garbage collection

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 什么是垃圾回收

js 会在创建变量时自动分配内存, 在不使用的是互殴自动周期性释放内存, 释放的过程成为 垃圾回收


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 优点 

js 自动分配内存空间, 减轻了开发者的负担, 不用过多的关注内存的使用


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 缺点

若不清楚内存回收机制, 很容易造成内存泄漏


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### recovery algorithm

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 回收算法

由于从根对象( 全局对象 )查找, 对于哪些无法从根对象查询到的对象都会被清除

回收后会形成内存碎片, 影响后面申请大的连续空间


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


- 标记清理( 2012 年后所有浏览器使用该策略 )


1. 变量进入上下文( 作用域 ), 会加上标记, 证明其内存在于该上下文

2. 将所有在上下文中的变量以及上下文中被访问引用的变量标记去除, 表明这些变量活跃有用

3. 在此之后将被加上标记的变量标记为准备删除的变量( 因上下文中的变量已无法访问它们 )

4. 执行内存清理, 销毁所有带标记的非活跃( 收回之前被占用的内存 ) 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


- 引用计数: 引用为 0 时, 回收内存


声明一个变量, 赋予它一个引用值             // 引用 + 1

同一个值被赋予另一个变量时                 // 引用 + 1

保存对该值引用的变量被其他值覆盖            // 引用 - 1


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### V8

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// V8 回收机制: 基于分代回收机制, 将内存分为 新生代 & 老生代


新生代: 存活时间较短的对象

老生代: 存活时间较长或常驻内存变量


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


新生代（New Space/Young Generation）： 大多数新生对象被分配到这，分为两块空间，整体占据小块空间，垃圾回收的频率较高，采用的回收算法为 Scavenge 算法
老生代（Old Space/Old Generation）：大多数在新生区存活一段时间后的对象会转移至此，采用的回收算法为 标记清除 & 整理（Mark-Sweep & Mark-Compact，Major GC） 算法，内部再细分为两个空间

指针空间（Old pointer space）: 存储的对象含有指向其他对象的指针
数据空间（Old data space）：存储的对象仅包含数据，无指向其他对象的指针
大对象空间（Large Object Space）：存放超过其他空间（Space）限制的大对象，垃圾回收器从不移动此空间中的对象
代码空间（Code Space）: 代码对象，用于存放代码段，是唯一拥有执行权限的内存空间，需要注意的是如果代码对象太大而被移入大对象空间，这个代码对象在大对象空间内也是拥有执行权限的，但不能因此说大对象空间也有执行权限
Cell空间、属性空间、Map空间 （Cell ,Property,Map Space）： 这些区域存放Cell、属性Cell和Map，每个空间因为都是存放相同大小的元素，因此内存结构很简单。


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


Scavenge 算法
Scavenge 算法是新生代空间中的主要算法，该算法由 C.J. Cheney 在 1970 年在论文 A nonrecursive list compacting algorithm 提出。
Scavenge 主要采用了 Cheney算法，Cheney算法新生代空间的堆内存分为2块同样大小的空间，称为 Semi space，处于使用状态的成为 From空间 ，闲置的称为 To 空间。垃圾回收过程如下：

检查From空间，如果From空间被分配满了，则执行Scavenge算法进行垃圾回收
如果未分配满，则检查From空间的是否有存活对象，如果无存活对象，则直接释放未存活对象的空间
如果存活，将检查对象是否符合晋升条件，如果符合晋升条件，则移入老生代空间，否则将对象复制进To空间
完成复制后将From和To空间角色互换，然后再从第一步开始执行


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


经历过一次Scavenge 算法筛选；
To空间内存使用超过25%；


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


标记清除 & 整理（Mark-Sweep & Mark-Compact，Major GC）算法
之前说过，标记清除策略会产生内存碎片，从而影响内存的使用，这里 标记整理算法（Mark-Compact）的出现就能很好的解决这个问题。标记整理算法是在 标记清除（Mark-Sweep ）的基础上演变而来的，整理算法会将活跃的对象往边界移动，完成移动后，再清除不活跃的对象
由于需要移动移动对象，所以在处理速度上，会慢于Mark-Sweep

全停顿（Stop The World ）
为了避免应用逻辑与垃圾回收器看到的逻辑不一样，垃圾回收器在执行回收时会停止应用逻辑，执行完回收任务后，再继续执行应用逻辑。这种行为就是 全停顿，停顿的时间取决与不同引擎执行一次垃圾回收的时间。这种停顿对新生代空间的影响较小，但对老生代空间可能会造成停顿的现象。

增量标记（Incremental Marking）
为了解决全停顿的现象，2011年V8推出了增量标记。V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直至标记完成。


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
