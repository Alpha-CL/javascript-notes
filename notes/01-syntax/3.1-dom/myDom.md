``` javascript
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 遍历元素节点树( 在原型链上编辑 )




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 封装函数返回 element 的第 n 层父级元素节点


// <div>
//     <strong>
//     <span>
//         <i></i>
//     </span>
//     </strong>
// </div>


<script>


function retParent(ele, num) {                  

    while (ele && num) {                        // 为了不超出 null 增加的条件

        ele = ele.parentElement;

        num--;
    }

    return ele;
}

var iObj = document.getElementsByTagName('i')[0];

console.log(retParent(iObj, 4));


</script>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 封装函数，返回 元素 e 的 第 n 个兄弟元素节点， 
 * n 为正，返回后面的兄弟元素节点，
 * n 为负，返回前面的兄弟元素节点，
 * n 为零，返回自己
 */
 
 
function retSibling(e, n) {

    while (e && n) {

        if (n > 0) {

            if (0 && e.nextElementSibling) {

                e = e.nextElementSibling;

            } else {

                for (e = e.nextSibling; e && e.nodeType != 1; e = e.nextSibling) ;
            }

            n--;

        } else {

            if (e.previousElementSibling) {

                e = e.previousElementSibling;

            } else {

                for (e = e.previousSibling; e && e.nodeType != 1; e = e.previousSibling) ;
            }
            n++;
        }
    }
    
    return e;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


``` javascript
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 编辑函数，封装 myChildren 功能，解决以前部分浏览器的兼容问题


Element.prototype.myChildren = function () {

    var eleChild = this.hasChildNodes(),
        len = eleChild.length,
        arr = [];

    for (var i = 0; i < len; i++) {

        if (eleChild[len].nodeType == 1) {

            arr.push(eleChild[len]);
        }
    }
    return arr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


``` javascript
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 自己封装 hasChildren(); 方法，不可用 children 属性




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


