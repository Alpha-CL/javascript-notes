#### ES6

#### ECMAScript, JavaScript, NodeJS 区别

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// ECMAScript, JavaScript, NodeJS 区别


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * ECMAScript
 * 
 * 
 * 简称 ES( 语言标准: 循环，判断，变量，数组等数组类型 )
 */


/**
 * JavaScript
 * 
 * 运行在浏览器端的语言，该语言使用 ES 标准
 * 
 * ES + webAPI = JavaScript
 */


/**
 * NodeJS
 * 
 * 运行在服务器端的语音，该语言使用 ES 标准
 * 
 * ES + nodeAPI = JavaScript    
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### let

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * let
 * 
 * 
 * let 生命的变量不会挂载到全局对象
 * 
 * let 声明的变量，不允许在当前作用域范围内重复声明
 */

在循环中 let 声明的循环变量 i，会特殊处理，每次进入熏昏都会创建一个新的作用域
并且将循环声明的变量绑定到该作用域( 每次循环，使用的都是一个全新的作用域 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### const

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 常量               // 常量不可变: 指声明常量的内存空间不可变
 *                                 并不能保证内存空间中地址指向的其他空间
 * 
 * 
 * const 和 let 在块级作用域中用法相同
 * 
 * const 声明的变量，必须在声明时赋值，而且不可以重新赋值
 */

开发中，应尽量使用 const 声明变量，以保证变量的值不会随意更改

for 循环中不能使用常量，for..in... 中可以使用常量

建议先使用 const，到浏览器返回出 此变量不能更改而需求需要更改时，再使用 let


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


常量命名

特殊常量命名规范: 全部字符用大写，单词之间用下横杠连接

普通常量命名规范: 和普通变量命名规范相同


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 块级作用域

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 块级作用域
 * 
 * 
 * 代码执行遇到 {}，就会创建一个块级作用域，大括号结束，会销毁块级别作用域
 * 
 * 在块级作用域中 let 声明的变量，仅在此作用域中有效，外部无法访问
 * 
 * 午饭变量提升，仅在声明后才可调用
 */


底层实现: let 声明的变量实际上也会提升，但是提升后会将其放入到 '暂时性死区'
         如果访问的变量位于暂时性死区，则会报错: 'Cannot access 'a' before initialization


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Unicode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


早期，由于存储空间宝贵，Unicode 使用二进制来存储文字，我们将一个 16 位的二进制编码成为 码元( Code Unit )

后来，由于技术发展，Unicode 文字编码进行了扩展，部分文字扩展到了 32 位置( 占用两个码元 )
并且，将部分文字对应的二进制数字称为码点( Code Point )


//-------------------------------------------------------------------------------------------------------------------//


/**
 * String.codePoint(num);
 * 
 * 
 * @num: 0 | 1;
 * 
 * 获取指定指定码点
 */

String.charCodeAt(1);               // 获取到两个码元

String.codePoint(1);                // 获取第一个码点


//-------------------------------------------------------------------------------------------------------------------//


/**
 * /regep/u                         // u
 * 
 * 根据码点匹配
 */


//-------------------------------------------------------------------------------------------------------------------//


function is32bit(char, i) {

    return charcondePointAt(i) > oxffff;                 // 判断是否是 32 位的数字
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


function getLengthOfCodePoint(str) {

    let len = 0;

    for(let i = 0; i < str.lenght; i++) {
    
        if (is32bit(str, i)) {
        
            i++;
        }
        
        len++;
    }
    return len;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


## String ES6 Method

#### str.includes()

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.includes(target: string, startIndex: number): boolean;
 * 
 * 
 * @target: 查找指定字符串，返回布尔值
 * 
 * @startIndex: 指定位置开始检索
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### str.startsWidth()

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.startsWidth(target: string, startIndex: number): boolean;
 * 
 * 判断字符串中是否以指定的字符串开始
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


#### str.endsWidth()

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.endsWidth(target: string, startIndex: number): boolean;
 * 
 * 判断字符串中是否以指定的字符串开始
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### str.repeat(number);

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * str.repeat(frequency: number);
 * 
 * 将字符床重复指定次数并返回，且是一个新的字符串
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


## Regex

#### /regex/y

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * /regex/y                     // y 
 * 
 * 默认匹配时，从 regex.lastIndex 位置开始匹配，并且在指定处若未能满足条件则直接返回结果( bloolean )
 */

// lastIndex  可更改


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Model String

#### 模版字符串

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * `txt, ${express} ${variable} ${express${express}}`
 * 
 * 模版字符串，方便格式，表达式&变量拼接，语义话更好            // 表达式可嵌套
 */

`fist-line ${variable1}
${variable1} second-line`


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * Extend model string
 * 
 * 
 */


let demo = myFn`alpah like${food}, beta like${food}`

=> myFn(alpah like, , beta , '');           // 被表达式分割的字符串作为参数传入


function myFn(param1, param2, param3 ...) {

     /**
      * 若在模版字符串之前写入函数名
      * 
      * 则会把模版字符串按照表达式分割为参数传入指定的函数
      */
    
    // param1 = 'alpah like';
    // param2 = ', beta like';
    // param3 = ''                  // 最后一个位置若没有任何内容会被定义为 空串
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * String.raw
 * 
 * 定义模版字符串中内容强制为字符串( 特殊符号不需要转译 )
 */

let demo = String.raw`hello \n world ${demo}`;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

















