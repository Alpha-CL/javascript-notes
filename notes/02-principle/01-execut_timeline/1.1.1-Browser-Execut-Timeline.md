# Browser Execute Timeline

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


- JS 引擎线程: 

    - 解释执行 JS 代码、用户输入、网络输入
    
    - JS 引擎线程 和 GUI 线程执行时，会相互等待，等待另一个执行后，再执行

- GUI 线程: 

    - 绘制用户界面 和 JS 主线程互斥

    - JS 操作 DOM 元素时，会影响 GUI 的渲染结果，因此 JS 引擎线程与GUI渲染是互斥的
    
    - 当 JS 引擎线程处于运行状态，GUI 渲染线程将处于冻结状态

- HTTP 网络请求线程: 

    - 处理用户的 get、post 等请求，等返回结果后将回掉函数推入任务队列
    
- 定时触发器线程:

    - setTimeout、setInterval 等事件结束后执行函数推入任务队列
    
- 浏览器事件监听线程

    - 将 click、mouse 等交互事件发生后将这些事件放入事件队列中


//-------------------------------------------------------------------------------------------------------------------//


| event queue
|                                                           + --- 浏览器定时触发线程
|                                                           |
| Javascript <- Javascript <- Mouse <- Timer <- Interval <- + --- 浏览器 http 异步请求线程
|     |          callback     click                         |
|     |                       callback                      + --- 浏览器事件触发线程
|   引擎线程  


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * dieLoop
 * 
 * 
 * 因为 JS 是单线程，所以无法忽略 while 循环，必须等 dieLoop 执行完才能执行 后面的代码
 */
 

<button id="btn"></button>

<script>


    var oBtn = document.getElementById('btn');


    dieLoop();
    
    function dieLoop() {

        while (true) {

        }
    }

    oBtn.onclick = function () {

        console.log('cab\'t view');

    };


</script>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### JS 为何是单线程

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


JS 设计出来是为了与用户交互，处理 DOM

若 JS 是多线程，同一时间一个线程想要修改 DOM，另一个线程想要删除 DOM，会导致浏览器无法选择线程

如果引入 'lock' 机制，则又跟其他语言的困境相同了


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### JS 执行机制

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


浏览器提供了恰好提供了这样的环境: 事件驱动 => ( 单线程 + 异步执行 )

- 单线程

- 异步执行


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Event Loop( 事件循环机制 )
 * 
 * 
 * 1.1: 同步和异步任务分别进入不同的执行 '场所'，同步进入主线程，异步进入 Event Table 并注册函数
 * 
 * 1.2: 当指定事件完成时，Event Table 会将这个函数植入 Event Queue
 * 
 * 1.3: 主线程的任务执行为空，会去 Event Queue 读取对应的函数，进入主线程执行
 * 
 * 
 * 1.1 -> 1.2 -> 1.3 -> 1.1 ... 1.3 -> 1.1 ... ( 无限循环 )
 * 
 */


        + --- 同步任务 -> 主线程 -> 任务全部执行完毕 --------------- +
        |                                                        |
执行栈 - +                                                        |
        |                                                        |
        + --- 异步任务 -> Event -> 注册回掉函数 -> Event ---------- + 
                         Table                  Queue            |
                                                                 |
                                                                
                                                 读取任务队列中的结果，进入主线程执行


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
* 同步任务
* 
* 
*/


function outer(ot) {

    function inter(it) {
    
        console.log(it);
    }

    innter(20);
    
    console.log(ot);
}

outer(10);


=> 20
   10


                   + -------- outer( 执行 ) --------- +
                   |                                 |
                   |                                 |
outer( 预编译 ) --> 栈 --> outer( 解析 )          innter( 执行 )
                   |        |                        ｜
                   |        |                        ｜
                   |        + -- innter( 预编译 ) --- +
                   |
               innter( 弹出栈 )
                   |
                   + -------------> outer( 弹出栈 ) -- 栈( 空 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 异步任务
 * 
 * 
 * Ajax 进入 Event Table，注册回掉函数 success
 * 
 * 执行 console.log('run1);
 * 
 * ajax 事件 完成 http 网络请求线程把任务放入 Event Queue 中
 * 
 * 主线程( 调用栈 )读取任务下执行的 success 函数
 */


$ajax({

    url: 'localhost:/js/demo/json',
    data: {},
    success: function(date) {
    
        console.log(date);
    }

});

console.log('run');


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



        + ------ JavaScript ------- +
        |                           |
        |                           |               + ------------------------ +
        |     heap       stack      |               |                          |
        |   + ----- +  + ------ +   |               |   Web APIs               |
        |   |       |  |        |   |               |                          |
        |   |  var  |  |  fn()  |---------------->  |   DOM( document )        |
        |   |       |  |        |   |               |                          |
        |   |       |  |        |   |               |   ajax( XMLHttpRequest)  |
        |   |       |  |        |   |               |                          |
        |   |       |  |        |   |               |   setTimeout             |
        |   |       |  |        |   |               |                          |
        |   + ----- +  + ------ +   |               + ------------------------ +
        |                           |                            |
        |                           |                            |
        + ------------------------- +                            |
                                                                 |
                                                                 |
    | Event Loop                                                 |
    |                                                            |
    |                                                            | 
    | callback <- onClick <- onLoad <- onDono ------------------ + 
    |  queue


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### callback

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


异步执行回调机制 callback

> 部分回调是异步的

> 由于 JavaScript 是 单线程，浏览器内部的其他模块帮助 js，使得 js 具有回调机制


//-------------------------------------------------------------------------------------------------------------------//


    /**
     * 回掉机制很好用
     * 
     * 
     * js 单线程 -> 异步编程优化体验 防止阻塞页面 -> 回调函数
     * 
     * 运动函数 animate 当你满足某个状态 接下来要做另一件事
     */


    + ------------------------------------------------------------------------------------- +      
    |                                                                                       | 
    |                                                                                       | 
    |                                                          Browser                      | 
    |            Single thread JS                                                           |
    |       + ---------------------- +                                                      |
    |       |                        |                                                      |               
    |       |  + ---------------- +  | Event listener thread                                |              
    |       |  |    bindEveent    |--------------------------------------------- +          |               
    |       |  + ---------------- +  |                                           |          |
    |       |                        |                                       + - + - +      | 
    |       |  + ---------------- +  | Network request thread                |       |      | 
    |       |  |      ajax        |----------------------------- +           |       |      | 
    |       |  + ---------------- +  |                           |           |       |      | 
    |       |                        |                       + - + - +       |       |      | 
    |       |  + ---------------- +  | Timer trigger thread  |       |       |       |      | 
    |       |  |   setInterval    |------------- +           |       |       |       |      | 
    |       |  + ---------------- +  |           |           |       |       |       |      | 
    |       |                        |       + - + - +       |       |       |       |      | 
    |       |  + ---------------- +  |       |       |       |       |       |       |      | 
    |       |  |                  |  |       |       |       |       |       |       |      | 
    |       |  + ---------------- +  |       |       |       |       |       |       |      | 
    |       |                        |       |       |       |       |       |       |      | 
    |       |  + ---------------- +  |       |       |       |       |       |       |      | 
    |       |  |                  |  |       + - + - +       + - + - +       + - + - +      | 
    |       |  + ---------------- +  |           |               |               |          |
    |       |                        |       + - + ------------- + ------------- + - +      |
    |       |  + ---------------- +  |       |                                       |      |
    |       |  | CompletedSnippet | <------- +             Task Queue                |      |
    |       |  + ---------------- +  |       |                                       |      |
    |       |                        |       + ------------------------------------- +      |
    |       + ---------------------- +                                                      |
    |                                                                                       |       
    |                                                                                       |       
    + ------------------------------------------------------------------------------------- +      


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 重新理解定时器

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


- setTimeout

    - 等待事件结束后并不是直接执行，而是先推入浏览器的一个任务队列
    
    - 在同步队列结束后一次调用任务队列中的任务
    
- setTimeout(function(), 0);

    - JS 主线执行栈为空时
    
    - 0 ms 也是达不到的，HTML 标准( 最低 4 ms )

- setInterval

    - 间隔相同的事件把任务推送至 Event Queue 中


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 因为 JS 的底层执行机制的限制导致
 * 
 * 计时器无法准确推送任务
 */

var startTime = new Date();

function sleep(time) {

    for(var i = 0; i < time; i++) {
    
        console.log(i);
    }
}

console.log(startTime);

setTimeout(function(){

    console.log(+new Date(); - startTime);
    
}, 100);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```








